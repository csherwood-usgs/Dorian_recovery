%% beryl_rankine_texas_overlay_and_setup.m
% Rankine vortex (+ translation) wind vectors from IBTrACS (NA basin),
% overlay on a line drawing of the Texas coast, and compute setup at a site.
%
% Requires: ibtracs.NA.list.v04r01.csv (IBTrACS v4r01 NA basin "list" file)
% Download:
% https://www.ncei.noaa.gov/data/international-best-track-archive-for-climate-stewardship-ibtracs/v04r01/access/csv/ibtracs.NA.list.v04r01.csv
%
% If you have the mapping toolbox, it will draw a shoreline (I think)
% This is a translation from Python to Matlab of beryl_matagorda.ipynb,
% also generated by ChatGPT.

% csherwood@usgs.gov

clear; clc;
have_mapping_toolbox = 0

%% -----------------------------
% User inputs
% -----------------------------
% need a copy of this file...download instructions above
ib_csv    = 'ibtracs.NA.list.v04r01.csv';

SID       = '2024181N09320';                 % Beryl 2024 storm id
% t_target  = datetime('2024-07-08 06:00:00','TimeZone','UTC'); % before landfall
% t_target  = datetime('2024-07-08 09:00:00','TimeZone','UTC'); % a little after landfall
t_target  = datetime('2024-07-08 12:00:00','TimeZone','UTC'); % after landfall
% t_target  = datetime('2024-07-08 08:40:00','TimeZone','UTC'); % closest to landfall


% Grid around storm center for plot
dlat  = 3.0;
dlon  = 3.0;
ngrid = 101; % increase for more attractive plot, decrease for speed

% Rankine model parameters
alpha_outer = 1.0;          % outer decay exponent
use_translation = true;     % add storm translation vector to wind field
beta_translation = 1.0;

% Site & lagoon parameters (E. Matagorda Bay) - CRS guesses
site_lat = 28.700;
site_lon = -95.838;
L_m      = 26000; % CRS measurement from GoogleEarth
h_m      = 2.0;   % CRS guess...water levels are sensitive to this
az_deg   = 65.0;

% Setup constants
rho_air = 1.225;
rho_w   = 1025.0;
g       = 9.81;
Cd      = 1.5e-3;    % choose your preferred drag formulation

%% -----------------------------
% Read IBTrACS NA list file
% -----------------------------
% IBTrACS list CSV has a "units row" at line 2; skip it.
opts = detectImportOptions(ib_csv);
opts.DataLines = [1 1; 3 Inf];   % read header line, then skip line 2, then rest
T = readtable(ib_csv, opts);

% Standardize column names
T.Properties.VariableNames = strtrim(T.Properties.VariableNames);

% Basic required columns
req = {'SID','ISO_TIME','LAT','LON'};
for k = 1:numel(req)
    if ~ismember(req{k}, T.Properties.VariableNames)
        error('Missing required column: %s', req{k});
    end
end

% Convert types
T.SID = string(strtrim(string(T.SID)));
T.ISO_TIME = datetime(string(T.ISO_TIME), 'TimeZone','UTC', 'InputFormat','yyyy-MM-dd HH:mm:ss');
T.LAT = double(T.LAT);
T.LON = double(T.LON);

% Filter to storm
S = T(T.SID == SID, :);
S = sortrows(S, 'ISO_TIME');

if isempty(S)
    error('No rows found for SID=%s. Check that SID and file match.', SID);
end

% Identify wind and RMW columns (prefer USA_* then WMO_*)
wind_col = pick_col(S, "WIND", ["USA_WIND","WMO_WIND"]);
rmw_col  = pick_col(S, "RMW",  ["USA_RMW","WMO_RMW"]);

if wind_col == ""
    error('No WIND-like column found in table.');
end
if rmw_col == ""
    error('No RMW-like column found in table.');
end

fprintf('Using wind column: %s\n', wind_col);
fprintf('Using RMW  column: %s\n', rmw_col);

% Coerce to numeric and clean missing sentinels
S.(wind_col) = toDoubleWithMissing(S.(wind_col));
S.(rmw_col)  = toDoubleWithMissing(S.(rmw_col));

% Require both wind and rmw to proceed
S2 = S(~isnan(S.(wind_col)) & ~isnan(S.(rmw_col)), :);
if isempty(S2)
    error('No fixes have both %s and %s populated for this SID.', wind_col, rmw_col);
end

% Choose fix nearest target time
[~, i0] = min(abs(S2.ISO_TIME - t_target));
fix = S2(i0,:);

latc = fix.LAT;
lonc = fix.LON;

% Units
kt_to_ms = 0.514444;
nm_to_m  = 1852.0;

Vmax_ms = fix.(wind_col) * kt_to_ms;
rmw_m   = fix.(rmw_col)  * nm_to_m;

%% -----------------------------
% Translation estimate (optional)
% -----------------------------
trans_ms = 0.0;
trans_hdg = 0.0;

if use_translation
    % Use adjacent points in S2 around i0
    if i0 > 1 && i0 < height(S2)
        prev = S2(i0-1,:);
        nxt  = S2(i0+1,:);

        dt_s = seconds(nxt.ISO_TIME - prev.ISO_TIME);
        if isfinite(dt_s) && dt_s > 0
            d_m = haversine_m(prev.LAT, prev.LON, nxt.LAT, nxt.LON);
            trans_ms = d_m / dt_s;
            trans_hdg = bearing_deg(prev.LAT, prev.LON, nxt.LAT, nxt.LON); % heading TO
        end
    end
end

fprintf('\nFix used: %s\n', string(fix.ISO_TIME));
fprintf('Center: lat=%.3f lon=%.3f\n', latc, lonc);
fprintf('%s=%.1f kt, %s=%.1f nm\n', wind_col, fix.(wind_col), rmw_col, fix.(rmw_col));
fprintf('Translation: %.2f m/s heading_to=%.1f deg (use_translation=%d)\n', ...
    trans_ms, trans_hdg, use_translation);

%% -----------------------------
% Build grid & compute wind field
% -----------------------------
latv = linspace(latc - dlat, latc + dlat, ngrid);
lonv = linspace(lonc - dlon, lonc + dlon, ngrid);
[LON, LAT] = meshgrid(lonv, latv);

[u, v] = wind_field_rankine(LAT, LON, latc, lonc, Vmax_ms, rmw_m, alpha_outer, ...
                            trans_ms, trans_hdg, beta_translation);

spd = hypot(u, v);

%% -----------------------------
% Plot: Texas coast line drawing + wind vectors
% -----------------------------
figure('Color','w'); hold on;

% A simple line-drawing coastline (built-in dataset).
% This is not “Texas-only”, but we’ll zoom the axes.
if( have_mapping_toolbox)
    coast = load('coastlines');
    plot(coast.coastlon, coast.coastlat, 'k-', 'LineWidth', 1.0);
end

% Optional speed shading (comment out for pure line+vectors)
pcolor(LON, LAT, spd); shading flat;
cb = colorbar; ylabel(cb, 'Wind speed (m/s)');

% Quiver (downsample)
step = max(1, floor(ngrid/18));
quiver(LON(1:step:end,1:step:end), LAT(1:step:end,1:step:end), ...
       u(1:step:end,1:step:end), v(1:step:end,1:step:end), ...
       'k');

% Storm center
plot(lonc, latc, 'ko', 'MarkerFaceColor','k');

% RMW circle (approx in degrees)
rmw_km = rmw_m/1000;
deg_lat = (rmw_m / 6371000.0) * (180/pi);
th = linspace(0, 2*pi, 361);
circle_lat = latc + deg_lat * sin(th);
circle_lon = lonc + (deg_lat * cos(th)) / cosd(latc);
plot(circle_lon, circle_lat, 'k--', 'LineWidth', 1.5);

% Site location
plot(site_lon, site_lat, 'ro', 'MarkerFaceColor','r');

% Set a Texas-coast-focused extent
xlim([-97 -95]);
ylim([28 29.5]);
axis equal;
grid on;
xlabel('Longitude (deg)');
ylabel('Latitude (deg)');

title(sprintf('Rankine(+trans=%d) winds: SID %s @ %s', use_translation, SID, string(fix.ISO_TIME)));

%% -----------------------------
% Point wind at site (compute directly, not interpolated from grid)
% -----------------------------
[u_pt, v_pt] = wind_field_rankine(site_lat, site_lon, latc, lonc, Vmax_ms, rmw_m, alpha_outer, ...
                                  trans_ms, trans_hdg, beta_translation);

U10 = hypot(u_pt, v_pt);

wind_dir_to   = EN_to_heading_deg(u_pt, v_pt);        % direction wind blows TOWARD
wind_dir_from = mod(wind_dir_to + 180.0, 360.0);      % meteorological "from"

% Cos^2 directional scaling relative to lagoon axis (using TO direction)
dtheta = angle_diff_deg(wind_dir_to, az_deg);
cos2   = (cosd(dtheta))^2;

% Setup (wind stress -> setup)
tau_eff = rho_air * Cd * (U10^2) * cos2;
eta_m   = (tau_eff * L_m) / (rho_w * g * h_m);

fprintf('\n--- Site wind & setup (E. Matagorda) ---\n');
fprintf('Site: lat=%.3f lon=%.3f\n', site_lat, site_lon);
fprintf('u_east=%.3f m/s, v_north=%.3f m/s, U10=%.3f m/s\n', u_pt, v_pt, U10);
fprintf('wind_dir_to=%.2f deg, wind_dir_from=%.2f deg\n', wind_dir_to, wind_dir_from);
fprintf('Lagoon az=%.1f deg; dtheta(to-az)=%.2f deg; cos^2=%.4f\n', az_deg, dtheta, cos2);
fprintf('tau_eff=%.4f Pa\n', tau_eff);
fprintf('eta_setup=%.4f m  (L=%.0f m, h=%.2f m)\n', eta_m, L_m, h_m);

%% =============================
% Local functions
% =============================
function col = pick_col(T, token, preferList)
    % Return a column name (string) that contains token.
    % Preference: any name in preferList if present; else first contains(token).
    vnames = string(T.Properties.VariableNames);
    col = "";
    for p = preferList
        if any(vnames == p)
            col = p; return;
        end
    end
    idx = find(contains(vnames, token), 1, 'first');
    if ~isempty(idx)
        col = vnames(idx);
    end
end


function x = toDoubleWithMissing(v)
    if isnumeric(v)
        x = double(v);
    elseif iscell(v)
        x = str2double(string(v));   % converts {'50'} -> 50
    elseif isstring(v) || iscategorical(v) || ischar(v)
        x = str2double(string(v));
    else
        x = str2double(string(v));
    end
    x(x == -9999 | x == -999 | x == -99) = NaN;
end


function d = haversine_m(lat1, lon1, lat2, lon2)
    R = 6371000.0;
    lat1 = deg2rad(lat1); lon1 = deg2rad(lon1);
    lat2 = deg2rad(lat2); lon2 = deg2rad(lon2);
    dlat = lat2 - lat1;
    dlon = lon2 - lon1;
    a = sin(dlat/2).^2 + cos(lat1).*cos(lat2).*sin(dlon/2).^2;
    d = 2*R*asin(sqrt(a));
end

function brng = bearing_deg(lat1, lon1, lat2, lon2)
    lat1 = deg2rad(lat1); lon1 = deg2rad(lon1);
    lat2 = deg2rad(lat2); lon2 = deg2rad(lon2);
    dlon = lon2 - lon1;
    x = sin(dlon).*cos(lat2);
    y = cos(lat1).*sin(lat2) - sin(lat1).*cos(lat2).*cos(dlon);
    brng = mod(rad2deg(atan2(x, y)) + 360.0, 360.0);
end

function [e, n] = heading_to_unit_EN(heading_deg)
    th = deg2rad(heading_deg);
    e = sin(th);
    n = cos(th);
end

function hdg = EN_to_heading_deg(e, n)
    hdg = mod(rad2deg(atan2(e, n)) + 360.0, 360.0);
end

function d = angle_diff_deg(a, b)
    % minimal signed difference a-b in [-180,180)
    d = mod((a - b) + 180.0, 360.0) - 180.0;
end

function V = rankine_speed(Vmax, r, rmw, alpha_outer)
    V = NaN(size(r));
    ok = isfinite(Vmax) & isfinite(rmw) & isfinite(r) & (rmw > 0) & (r > 0);
    rin = ok & (r <= rmw);
    rout = ok & (r > rmw);
    V(rin)  = Vmax .* (r(rin) ./ rmw);
    V(rout) = Vmax .* (rmw ./ r(rout)).^alpha_outer;
end

function [u, v] = wind_field_rankine(lat, lon, latc, lonc, Vmax, rmw_m, alpha_outer, ...
                                     trans_ms, trans_hdg, beta_translation)
    % Compute east/north wind components (m/s) from Rankine tangential + translation.
    % lat/lon may be scalars or arrays.

    % distance + bearing center->point(s)
    r = haversine_m(latc, lonc, lat, lon);
    br = bearing_deg(latc, lonc, lat, lon);

    % radial unit vectors (east/north)
    [e_r, n_r] = heading_to_unit_EN(br);

    % tangential unit vectors (NH): rotate +90°
    e_t = -n_r;
    n_t =  e_r;

    Vtan = rankine_speed(Vmax, r, rmw_m, alpha_outer);

    % translation vector
    [e_tr, n_tr] = heading_to_unit_EN(trans_hdg);
    u_tr = beta_translation * trans_ms * e_tr;
    v_tr = beta_translation * trans_ms * n_tr;

    u = Vtan .* e_t + u_tr;
    v = Vtan .* n_t + v_tr;
end
